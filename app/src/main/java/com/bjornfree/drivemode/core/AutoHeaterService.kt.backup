package com.bjornfree.drivemode.core

import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.Service
import android.car.VehiclePropertyIds
import android.content.Context
import android.content.Intent
import android.os.Build
import android.os.IBinder
import android.util.Log
import androidx.core.app.NotificationCompat
import kotlinx.coroutines.*
import kotlin.math.abs
import java.lang.reflect.Method

/**
 * Data class для хранения данных о давлении и температуре одной шины
 */
data class TireData(
    val pressure: Int?,  // Давление в кПа
    val temperature: Int? // Температура в °C
)

/**
 * Data class для хранения данных всех 4 шин
 */
data class TirePressureData(
    val frontLeft: TireData,
    val frontRight: TireData,
    val rearLeft: TireData,
    val rearRight: TireData
)

/**
 * Отдельный сервис для авто-подогрева сидений.
 * Новый сценарий:
 *  - стартуем foreground сервис (при старте ГУ / приложения);
 *  - он ПОСТОЯННО мониторит состояние зажигания в фоне;
 *  - при переходе OFF/ACC -> ON/START автоматически включает подогрев;
 *  - НЕ ОСТАНАВЛИВАЕТСЯ, работает пока не убьют (START_STICKY).
 */
class AutoSeatHeatService : Service() {

    companion object {
        private const val TAG = "AutoSeatHeatService"

        // VehicleProperty IDs
        private const val VEHICLE_PROPERTY_IGNITION_STATE = 289408009
        private const val VEHICLE_PROPERTY_HVAC_SEAT_TEMPERATURE = 356517131

        // ECARX/Geely Coolray custom properties (найдены в дампе)
        private const val ECARX_PROPERTY_CABIN_TEMPERATURE = 0x2140a379   // AC_INSIDE_TEMP: Integer, температура в салоне °C
        private const val ECARX_PROPERTY_RANGE_REMAINING = 0x11400308     // RANGE_REMAINING: Float = остаток запаса хода км ✅
        private const val ECARX_PROPERTY_ODOMETER = 0x11400204            // PERF_ODOMETER: Float = пробег км
        private const val ECARX_PROPERTY_AVERAGE_FUEL = 0x2740a665        // AVERAGE_FUEL_CONSUMPTION: Float = средний расход л/100км
        private const val ECARX_PROPERTY_FUEL_CAPACITY = 0x11600104       // INFO_FUEL_CAPACITY: Float = ёмкость бака л

        // TPMS (Tire Pressure Monitoring System) свойства
        private const val ECARX_PROPERTY_TPMS_PRESSURE_FL = 0x2140a456    // Давление переднее левое (кПа)
        private const val ECARX_PROPERTY_TPMS_PRESSURE_FR = 0x2140a457    // Давление переднее правое (кПа)
        private const val ECARX_PROPERTY_TPMS_PRESSURE_RL = 0x2140a458    // Давление заднее левое (кПа)
        private const val ECARX_PROPERTY_TPMS_PRESSURE_RR = 0x2140a459    // Давление заднее правое (кПа)
        private const val ECARX_PROPERTY_TPMS_TEMP_FL = 0x2140a460        // Температура переднее левое (°C)
        private const val ECARX_PROPERTY_TPMS_TEMP_FR = 0x2140a461        // Температура переднее правое (°C)
        private const val ECARX_PROPERTY_TPMS_TEMP_RL = 0x2140a462        // Температура заднее левое (°C)
        private const val ECARX_PROPERTY_TPMS_TEMP_RR = 0x2140a463        // Температура заднее правое (°C)

        // Дополнительные температурные свойства
        private const val ECARX_PROPERTY_AMBIENT_TEMP = 0x2140a377        // AC_AMBIENT_TEMP: температура снаружи
        private const val ECARX_PROPERTY_ENGINE_OIL_TEMP = 0x11600304     // ENGINE_OIL_TEMP: температура масла двигателя
        private const val ECARX_PROPERTY_COOLANT_TEMP = 0x2140a578        // IPKINFO_COOLAN_TEMP: температура охлаждающей жидкости

        // ТОП-10 полезных свойств
        private const val ECARX_PROPERTY_VEHICLE_SPEED = 0x11600207       // PERF_VEHICLE_SPEED: скорость автомобиля
        private const val ECARX_PROPERTY_ENGINE_RPM = 0x2140a609          // ENGINE_RPM: обороты двигателя
        private const val ECARX_PROPERTY_ENGINE_OIL_LEVEL = 0x11400303    // ENGINE_OIL_LEVEL: уровень масла
        private const val ECARX_PROPERTY_GEAR_SELECTION = 0x11400401      // GEAR_SELECTION: текущая передача
        private const val ECARX_PROPERTY_PM25_STATUS = 0x2140a358         // AC_PM25STS: качество воздуха PM2.5
        private const val ECARX_PROPERTY_BATTERY_LEVEL = 0x2140309b       // BODY_BATTERY_BCN_LEVEL: уровень 12В батареи
        private const val ECARX_PROPERTY_NIGHT_MODE = 0x11400501          // NIGHT_MODE: ночной режим
        private const val ECARX_PROPERTY_DRIVE_MILEAGE = 0x2740a679       // DRIVE_MILEAGE: пробег поездки
        private const val ECARX_PROPERTY_DRIVE_TIME = 0x2740a67a          // DRIVE_TIME: время поездки

        const val PREF_LAST_IGNITION_STATE = "last_ignition_state"
        const val PREF_LAST_IGNITION_TIMESTAMP = "last_ignition_timestamp"
        const val PREF_LAST_IGNITION_OFF_TIMESTAMP = "last_ignition_off_timestamp"
        const val FRESH_START_WINDOW_MS = 60_000L // 60 секунд - окно для определения свежего старта
        @Volatile
        private var isRunning = false

        @Volatile
        private var serviceInstance: AutoSeatHeatService? = null

        // Запуск сервиса «по-обычному»
        fun start(context: Context) {
            val i = Intent(context, AutoSeatHeatService::class.java)
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                context.startForegroundService(i)
            } else {
                context.startService(i)
            }
        }

        // Тест автоподогрева (аналог triggerSeatHeatTest)
        fun startTest(context: Context) {
            val i = Intent(context, AutoSeatHeatService::class.java)
                .putExtra("test", true)
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                context.startForegroundService(i)
            } else {
                context.startService(i)
            }
        }

        // Получение температуры в салоне
        fun getCabinTemperature(): Float? {
            return serviceInstance?.readCabinTemperature()
        }

        // Получение температуры снаружи
        fun getAmbientTemperature(): Float? {
            return serviceInstance?.readAmbientTemperature()
        }

        fun getFuel(): Float? {
            return serviceInstance?.readFuel()
        }

        fun getOdometer(): Float? {
            return serviceInstance?.readOdometer()
        }

        fun getAverageFuel(): Float? {
            return serviceInstance?.readAverageFuel()
        }

        fun getFuelCapacity(): Float? {
            return serviceInstance?.readFuelCapacity()
        }

        // Получение пробега поездки
        fun getTripMileage(): Float? {
            return serviceInstance?.readTripMileage()
        }

        // Получение времени поездки (в минутах)
        fun getTripTime(): Float? {
            return serviceInstance?.readTripTime()
        }

        // Получение текущей передачи
        fun getGearSelection(): String? {
            return serviceInstance?.readGearSelection()
        }

        // Получение температуры масла двигателя
        fun getOilTemperature(): Float? {
            return serviceInstance?.readOilTemperature()
        }

        // Получение температуры охлаждающей жидкости
        fun getCoolantTemperature(): Float? {
            return serviceInstance?.readCoolantTemperature()
        }

        // Получение скорости автомобиля
        fun getVehicleSpeed(): Float? {
            return serviceInstance?.readVehicleSpeed()
        }

        // Получение оборотов двигателя
        fun getEngineRPM(): Float? {
            return serviceInstance?.readEngineRPM()
        }

        fun testAllFuelProperties() {
            serviceInstance?.testFuelProperties()
        }

        // Получение данных TPMS (давление и температура шин)
        fun getTirePressureData(): TirePressureData? {
            return serviceInstance?.readTirePressureData()
        }

        // Проверка запущен ли сервис
        fun isServiceRunning(): Boolean {
            return isRunning && serviceInstance != null
        }

        /**
         * Перезапускает сервис автоподогрева
         */
        fun restartService(context: Context) {
            try {
                DriveModeService.logConsole("AutoSeatHeatService: Принудительный перезапуск...")
                context.stopService(Intent(context, AutoSeatHeatService::class.java))
                Thread.sleep(500)
                context.startForegroundService(Intent(context, AutoSeatHeatService::class.java))
                DriveModeService.logConsole("AutoSeatHeatService: Перезапущен успешно")
            } catch (e: Exception) {
                DriveModeService.logConsole("AutoSeatHeatService: Ошибка перезапуска: ${e.message}")
            }
        }

        /**
         * Диагностика всех температурных свойств и RPM с разными area
         */
        fun diagnosticTemperaturesAndRPM() {
            DriveModeService.clearConsole()
            DriveModeService.logConsole("=== ДИАГНОСТИКА ТЕМПЕРАТУР И RPM ===")
            DriveModeService.logConsole("")

            serviceInstance?.runTemperatureAndRPMDiagnostic()
        }
    }


    private var carObj: Any? = null
    private var carPropertyManagerObj: Any? = null

    private val scope = CoroutineScope(SupervisorJob() + Dispatchers.IO)
    private var monitorJob: Job? = null
    private var metricsUpdateJob: Job? = null
    private var lastIgnitionState: Int? = null
    private var heatingAppliedForCurrentSession = false


    /**
     * Логирует ошибку только если она отличается от предыдущей.
     * Использует централизованную систему дедупликации из DriveModeService.
     */
    private fun logErrorOnce(message: String) {
        DriveModeService.logConsoleOnce(message)
    }

    /**
     * Сбрасывает состояние ошибки при успешной операции.
     */
    private fun resetErrorState() {
        DriveModeService.resetLogState("AutoSeatHeatService")
    }

    override fun onCreate() {
        super.onCreate()
        isRunning = true
        serviceInstance = this
        startForeground(2, buildNotification())
        DriveModeService.logConsole("AutoSeatHeatService: onCreate, starting ignition monitoring")

        // Проверяем "свежий старт" зажигания при перезапуске сервиса
        scope.launch {
            checkFreshIgnitionStart()
        }

        // Запускаем постоянный мониторинг зажигания
        startIgnitionMonitoring()

        // Запускаем периодическое обновление метрик (температура, топливо)
        startMetricsUpdate()
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        val test = intent?.getBooleanExtra("test", false) == true

        if (test) {
            // Тестовый режим - применяем подогрев сразу и не останавливаемся
            DriveModeService.logConsole("AutoSeatHeatService: test start")
            scope.launch {
                applyAutoSeatHeat(test = true)
            }
            return START_STICKY
        }

        // Обычный режим - мониторинг уже запущен в onCreate
        return START_STICKY
    }

    override fun onTaskRemoved(rootIntent: Intent?) {
        super.onTaskRemoved(rootIntent)
        DriveModeService.logConsole("AutoSeatHeatService: onTaskRemoved - перезапускаем сервис")

        // Перезапускаем сервис при удалении задачи (swipe away)
        val restartIntent = Intent(applicationContext, AutoSeatHeatService::class.java)
        applicationContext.startForegroundService(restartIntent)
    }

    override fun onDestroy() {
        super.onDestroy()
        isRunning = false
        serviceInstance = null
        monitorJob?.cancel()
        metricsUpdateJob?.cancel()
        scope.cancel()
        DriveModeService.logConsole("AutoSeatHeatService: onDestroy")
    }

    override fun onBind(intent: Intent?): IBinder? = null

    /**
     * Запускает периодическое обновление метрик (температура, топливо).
     * Обновляется каждые 30 секунд только при включенном зажигании.
     */
    private fun startMetricsUpdate() {
        metricsUpdateJob = scope.launch {
            while (isActive) {
                try {
                    // Читаем метрики только если зажигание включено
                    val currentIgnitionState = readIgnitionState()
                    if (currentIgnitionState != -1 && isIgnitionOnLike(currentIgnitionState)) {
                        // Читаем температуру
                        readCabinTemperature()

                        // Читаем топливо
                        readFuel()

                        // Можно также читать средний расход и одометр
                        readAverageFuel()
                        // readOdometer() // Одометр обычно не так критичен, можно закомментировать
                    }
                } catch (e: Exception) {
                    // Игнорируем ошибки, не спамим в лог - используем логику dedupe в самих методах чтения
                }

                // Обновляем каждые 30 секунд
                delay(2_000)
            }
        }
    }

    private fun startIgnitionMonitoring() {
        monitorJob = scope.launch {
            var consecutiveErrors = 0
            while (isActive) {
                try {
                    val currentState = readIgnitionState()

                    if (currentState != -1) {
                        consecutiveErrors = 0 // Сброс счетчика ошибок при успешном чтении

                        val isOn = isIgnitionOnLike(currentState)
                        val wasOn = lastIgnitionState?.let { isIgnitionOnLike(it) } ?: false

                        // Детектируем переход OFF -> ON
                        if (isOn && !wasOn && lastIgnitionState != null) {
                            DriveModeService.logConsole(
                                "AutoSeatHeatService: ignition OFF->ON transition detected ($lastIgnitionState -> $currentState)"
                            )

                            // Применяем подогрев только один раз за эту сессию включения
                            if (!heatingAppliedForCurrentSession) {
                                try {
                                    applyAutoSeatHeat(test = false)
                                    heatingAppliedForCurrentSession = true
                                } catch (e: Exception) {
                                    DriveModeService.logConsole(
                                        "AutoSeatHeatService: ERROR applying heat: ${e.javaClass.simpleName}: ${e.message}"
                                    )
                                    Log.e(TAG, "Error applying seat heat", e)
                                }
                            }
                        }

                        // Сбрасываем флаг при выключении зажигания
                        if (!isOn && wasOn) {
                            DriveModeService.logConsole(
                                "AutoSeatHeatService: ignition ON->OFF transition ($lastIgnitionState -> $currentState)"
                            )
                            heatingAppliedForCurrentSession = false

                            // Сохраняем timestamp выключения зажигания
                            saveIgnitionOffTimestamp()
                        }

                        // Сохраняем текущее состояние в SharedPreferences
                        saveIgnitionState(currentState, isOn)
                        lastIgnitionState = currentState
                    } else {
                        consecutiveErrors++
                    }
                } catch (e: Exception) {
                    consecutiveErrors++
                    DriveModeService.logConsole(
                        "AutoSeatHeatService: monitor error (#$consecutiveErrors): ${e.javaClass.simpleName}: ${e.message}"
                    )
                    Log.e(TAG, "Monitor loop error", e)

                    // Если слишком много ошибок подряд, пробуем переинициализировать CarPropertyManager
                    if (consecutiveErrors >= 10) {
                        DriveModeService.logConsole(
                            "AutoSeatHeatService: Too many errors, reinitializing CarPropertyManager..."
                        )
                        carObj = null
                        carPropertyManagerObj = null
                        delay(5000) // Пауза перед повторной инициализацией
                    }
                }

                // Проверяем каждые 2 секунды для быстрой реакции на включение зажигания
                delay(2000)
            }
        }
    }

    /**
     * Проверяет "свежий старт" зажигания при запуске сервиса.
     * Если зажигание ON и недавно было OFF - применяем подогрев.
     */
    private suspend fun checkFreshIgnitionStart() {
        try {
            delay(500) // Даем время на инициализацию CarPropertyManager

            val currentState = readIgnitionState()
            if (currentState == -1) {
                DriveModeService.logConsole("AutoSeatHeatService: не удалось прочитать состояние зажигания при старте")
                return
            }

            val isCurrentlyOn = isIgnitionOnLike(currentState)
            if (!isCurrentlyOn) {
                DriveModeService.logConsole("AutoSeatHeatService: зажигание выключено при старте сервиса")
                return
            }

            val prefs = getSharedPreferences("drivemode_prefs", Context.MODE_PRIVATE)
            val lastSavedState = prefs.getInt(PREF_LAST_IGNITION_STATE, -1)
            val lastOffTimestamp = prefs.getLong(PREF_LAST_IGNITION_OFF_TIMESTAMP, 0L)
            val currentTime = System.currentTimeMillis()

            // Проверяем: было ли недавно выключение зажигания
            val timeSinceOff = if (lastOffTimestamp > 0) currentTime - lastOffTimestamp else Long.MAX_VALUE
            val wasPreviouslyOff = lastSavedState == -1 || !isIgnitionOnLike(lastSavedState)

            DriveModeService.logConsole(
                "AutoSeatHeatService: проверка свежего старта - текущее=$currentState(ON), " +
                "предыдущее=$lastSavedState, времяСВыключения=${timeSinceOff}мс"
            )

            // Условия для "свежего старта":
            // 1. Зажигание сейчас ON
            // 2. Последнее сохраненное состояние было OFF (или нет данных)
            // 3. С момента выключения прошло меньше FRESH_START_WINDOW_MS (60 сек)
            if (wasPreviouslyOff && timeSinceOff < FRESH_START_WINDOW_MS) {
                DriveModeService.logConsole(
                    "AutoSeatHeatService: ОБНАРУЖЕН свежий старт зажигания " +
                    "(${timeSinceOff}мс с момента OFF), применяем подогрев"
                )

                // Применяем подогрев с проверкой всех условий (температура, настройки и т.д.)
                try {
                    applyAutoSeatHeat(test = false)
                    heatingAppliedForCurrentSession = true
                } catch (e: Exception) {
                    DriveModeService.logConsole(
                        "AutoSeatHeatService: ошибка применения подогрева при свежем старте: " +
                        "${e.javaClass.simpleName}: ${e.message}"
                    )
                    Log.e(TAG, "Error applying heat on fresh start", e)
                }
            } else if (wasPreviouslyOff) {
                DriveModeService.logConsole(
                    "AutoSeatHeatService: зажигание было выключено, но прошло слишком много времени " +
                    "(${timeSinceOff}мс), подогрев не применяется"
                )
            } else {
                DriveModeService.logConsole(
                    "AutoSeatHeatService: зажигание уже было включено, подогрев не применяется"
                )
            }

            // Обновляем сохраненное состояние
            saveIgnitionState(currentState, isCurrentlyOn)
            lastIgnitionState = currentState

        } catch (e: Exception) {
            DriveModeService.logConsole(
                "AutoSeatHeatService: ошибка проверки свежего старта: ${e.javaClass.simpleName}: ${e.message}"
            )
            Log.e(TAG, "Error checking fresh ignition start", e)
        }
    }

    /**
     * Сохраняет текущее состояние зажигания в SharedPreferences.
     */
    private fun saveIgnitionState(state: Int, isOn: Boolean) {
        try {
            val prefs = getSharedPreferences("drivemode_prefs", Context.MODE_PRIVATE)
            prefs.edit().apply {
                putInt(PREF_LAST_IGNITION_STATE, state)
                putLong(PREF_LAST_IGNITION_TIMESTAMP, System.currentTimeMillis())
                apply()
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error saving ignition state", e)
        }
    }

    /**
     * Сохраняет timestamp выключения зажигания.
     */
    private fun saveIgnitionOffTimestamp() {
        try {
            val prefs = getSharedPreferences("drivemode_prefs", Context.MODE_PRIVATE)
            prefs.edit().apply {
                putLong(PREF_LAST_IGNITION_OFF_TIMESTAMP, System.currentTimeMillis())
                apply()
            }
            DriveModeService.logConsole("AutoSeatHeatService: сохранен timestamp выключения зажигания")
        } catch (e: Exception) {
            Log.e(TAG, "Error saving ignition off timestamp", e)
        }
    }

    private fun buildNotification(): Notification {
        val chId = "auto_seat_heat"
        if (Build.VERSION.SDK_INT >= 26) {
            val ch = NotificationChannel(
                chId,
                "Auto seat heating",
                NotificationManager.IMPORTANCE_MIN
            )
            (getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager)
                .createNotificationChannel(ch)
        }
        return NotificationCompat.Builder(this, chId)
            .setSmallIcon(android.R.drawable.ic_menu_compass)
            .setContentTitle("Auto seat heating")
            .setContentText("Контроль подогрева сидений")
            .setOngoing(true)
            .build()
    }

    private fun isIgnitionOnLike(state: Int): Boolean {
        // Подстрой под реальные значения, если нужно.
        return when (state) {
            4, 5 -> true        // START / RUN
            2, 0 -> false       // ACC / OFF
            else -> false
        }
    }

    private fun ensureCarPropertyManager(): Boolean {
        try {
            Class.forName("android.car.Car")
            Class.forName("android.car.hardware.property.CarPropertyManager")
        } catch (_: ClassNotFoundException) {
            return false
        } catch (_: Exception) {
            return false
        }
        if (carObj != null && carPropertyManagerObj != null) return true

        return try {
            val carClass = Class.forName("android.car.Car")
            val cpmClass = Class.forName("android.car.hardware.property.CarPropertyManager")

            val createCar = carClass.getMethod("createCar", Context::class.java)
            val carInstance = createCar.invoke(null, this)

            val getCarManagerByClass = try {
                carClass.getMethod("getCarManager", Class::class.java)
            } catch (_: NoSuchMethodException) {
                null
            }

            val pm: Any? = if (getCarManagerByClass != null) {
                getCarManagerByClass.invoke(carInstance, cpmClass)
            } else {
                val getCarManagerByString =
                    carClass.getMethod("getCarManager", String::class.java)
                val propertyServiceField = carClass.getField("PROPERTY_SERVICE")
                val propertyService = try {
                    propertyServiceField.get(null) as? String
                } catch (_: Exception) {
                    propertyServiceField.get(carInstance) as? String
                }
                if (propertyService == null) null
                else getCarManagerByString.invoke(carInstance, propertyService)
            }

            if (pm == null) {
                carObj = carInstance
                carPropertyManagerObj = null
                false
            } else {
                carObj = carInstance
                carPropertyManagerObj = pm
                true
            }
        } catch (e: Exception) {
            Log.e(TAG, "ensureCarPropertyManager error", e)
            carObj = null
            carPropertyManagerObj = null
            false
        }
    }

    private data class CarAccess(
        val pm: Any,
        val cpmClass: Class<*>,
        val getIntProperty: Method,
        val getFloatProperty: Method
    )

    private fun obtainCarAccess(): CarAccess? {
        if (!ensureCarPropertyManager()) return null
        val pmObj = carPropertyManagerObj ?: return null

        return try {
            val cpmClass = Class.forName("android.car.hardware.property.CarPropertyManager")
            val getIntProperty = cpmClass.getMethod(
                "getIntProperty",
                Int::class.javaPrimitiveType,
                Int::class.javaPrimitiveType
            )
            val getFloatProperty = cpmClass.getMethod(
                "getFloatProperty",
                Int::class.javaPrimitiveType,
                Int::class.javaPrimitiveType
            )
            CarAccess(pmObj, cpmClass, getIntProperty, getFloatProperty)
        } catch (e: Exception) {
            Log.e(TAG, "obtainCarAccess error", e)
            null
        }
    }

    private inline fun <T> withCarAccess(errorTag: String, block: (CarAccess) -> T?): T? {
        val access = obtainCarAccess()
        if (access == null) {
            logErrorOnce("$errorTag - CarPropertyManager not available")
            return null
        }
        return try {
            block(access)
        } catch (e: Exception) {
            logErrorOnce("$errorTag: ${e.javaClass.simpleName}: ${e.message}")
            Log.e(TAG, errorTag, e)
            null
        }
    }

    private fun CarAccess.readInt(propertyId: Int, areaId: Int = 0): Int? =
        try {
            getIntProperty.invoke(pm, propertyId, areaId) as Int
        } catch (_: Exception) {
            null
        }

    private fun CarAccess.readFloat(propertyId: Int, areaId: Int = 0): Float? =
        try {
            getFloatProperty.invoke(pm, propertyId, areaId) as Float
        } catch (_: Exception) {
            null
        }

    private fun readIgnitionState(): Int {
        if (!ensureCarPropertyManager()) {
            // НЕ логируем каждый раз - только в monitoring loop при consecutiveErrors >= 5
            return -1
        }
        val pmObj = carPropertyManagerObj ?: return -1
        return try {
            val cpmClass = Class.forName("android.car.hardware.property.CarPropertyManager")
            val getIntProperty = cpmClass.getMethod(
                "getIntProperty",
                Int::class.javaPrimitiveType,
                Int::class.javaPrimitiveType
            )
            val value = getIntProperty.invoke(pmObj, VEHICLE_PROPERTY_IGNITION_STATE, 0) as Int
            value
        } catch (e: Exception) {
            // НЕ логируем каждый раз - только в monitoring loop при consecutiveErrors >= 5
            -1
        }
    }

    /**
     * Читает температуру В САЛОНЕ (пробует разные property ID).
     * @return температура в салоне в °C или null при ошибке
     */
    /**
     * Читает температуру В САЛОНЕ.
     * @return температура в салоне в °C или null при ошибке
     */
    fun readCabinTemperature(): Float? = withCarAccess(
        "AutoSeatHeatService: readCabinTemperature"
    ) { access ->
        // Единственный кандидат - температура в салоне
        val propertyId = 0x2140a379 // AC_INSIDE_TEMP

        try {
            val raw = access.readInt(propertyId, 0) ?: return@withCarAccess null
            val temperature = (raw - 80) / 2f

            if (temperature in -40f..80f) {
                resetErrorState()
                return@withCarAccess temperature
            }
        } catch (_: Exception) {
            // Ошибка чтения property - вернём null
        }

        logErrorOnce("AutoSeatHeatService: Не удалось прочитать температуру в салоне (AC_INSIDE_TEMP RAW->°C)")
        null
    }

    /**
     * Читает температуру СНАРУЖИ (пробует разные property ID).
     * @return температура снаружи в °C или null при ошибке
     */
    fun readAmbientTemperature(): Float? = withCarAccess(
        "AutoSeatHeatService: readAmbientTemperature"
    ) { access ->
        // Единственный кандидат - наружная температура
        val propertyId = 0x2140a377 // AC_AMBIENT_TEMP

        try {
            val raw = access.readInt(propertyId, 0) ?: return@withCarAccess null
            val temperature = (raw - 80) / 2f

            if (temperature in -50f..80f) {
                resetErrorState()
                return@withCarAccess temperature
            }
        } catch (_: Exception) {
            // Ошибка чтения property - вернём null
        }

        logErrorOnce("AutoSeatHeatService: Не удалось прочитать температуру снаружи (AC_AMBIENT_TEMP RAW->°C)")
        null
    }

    /**
     * Читает уровень топлива, вычисляя его из остатка запаса хода и среднего расхода.
     * @return уровень топлива в литрах или null при ошибке
     */
    fun readFuel(): Float? = withCarAccess(
        "AutoSeatHeatService: readFuel"
    ) { access ->
        val rangeRemaining = access.readFloat(ECARX_PROPERTY_RANGE_REMAINING, 0)
        if (rangeRemaining == null || rangeRemaining <= 0f) {
            logErrorOnce("AutoSeatHeatService: RANGE_REMAINING = $rangeRemaining (невалидное)")
            return@withCarAccess null
        }

        val avgFuelConsumption = readAverageFuel() ?: 10f
        val fuelLiters = (rangeRemaining / 100f) * avgFuelConsumption

        if (fuelLiters in 0f..60f) {
            resetErrorState()
            fuelLiters
        } else {
            logErrorOnce("AutoSeatHeatService: Невалидное вычисленное топливо: ${fuelLiters}L")
            null
        }
    }

    /**
     * Читает показание одометра (пробег).
     * @return пробег в километрах или null при ошибке
     */
    fun readOdometer(): Float? = withCarAccess(
        "AutoSeatHeatService: readOdometer"
    ) { access ->
        val odometer = access.readFloat(ECARX_PROPERTY_ODOMETER, 0)
        return@withCarAccess odometer?.also { resetErrorState() }
    }

    /**
     * Читает емкость топливного бака.
     * @return емкость бака в литрах или null при ошибке
     */
    fun readFuelCapacity(): Float? = withCarAccess(
        "AutoSeatHeatService: readFuelCapacity"
    ) { access ->
        val capacity = access.readFloat(ECARX_PROPERTY_FUEL_CAPACITY, 0)
        if (capacity != null && capacity in 30f..100f) {
            resetErrorState()
            DriveModeService.logConsole(
                "AutoSeatHeatService: Емкость бака (0x${ECARX_PROPERTY_FUEL_CAPACITY.toString(16)}): ${capacity} л"
            )
            return@withCarAccess capacity
        }
        if (capacity != null) {
            logErrorOnce("AutoSeatHeatService: Невалидная емкость бака: ${capacity}L")
        }
        null
    }

    /**
     * Читает средний расход топлива.
     * @return средний расход в л/100км или null при ошибке
     */
    fun readAverageFuel(): Float? = withCarAccess(
        "AutoSeatHeatService: readAverageFuel"
    ) { access ->
        val areaIds = listOf(0, 1, 2)

        for (areaId in areaIds) {
            val avgFuel = access.readFloat(ECARX_PROPERTY_AVERAGE_FUEL, areaId)
            if (avgFuel != null && avgFuel in 0f..50f) {
                resetErrorState()
                return@withCarAccess avgFuel
            }
        }

        for (areaId in areaIds) {
            val rawInt = access.readInt(ECARX_PROPERTY_AVERAGE_FUEL, areaId) ?: continue
            val avgFuel = rawInt / 10f
            if (avgFuel in 0f..50f) {
                resetErrorState()
                return@withCarAccess avgFuel
            }
        }

        logErrorOnce("AutoSeatHeatService: Не удалось прочитать средний расход ни с одним из методов")
        null
    }

    /**
     * Читает пробег текущей поездки.
     * @return пробег поездки в километрах или null при ошибке
     */
    fun readTripMileage(): Float? = withCarAccess(
        "AutoSeatHeatService: readTripMileage"
    ) { access ->
        val mileage = access.readFloat(ECARX_PROPERTY_DRIVE_MILEAGE, 1)
        return@withCarAccess mileage?.also { resetErrorState() }
    }

    /**
     * Читает время текущей поездки.
     * @return время поездки в минутах или null при ошибке
     */
    fun readTripTime(): Float? = withCarAccess(
        "AutoSeatHeatService: readTripTime"
    ) { access ->
        val time = access.readFloat(ECARX_PROPERTY_DRIVE_TIME, 1)
        return@withCarAccess time?.also { resetErrorState() }
    }

    /**
     * Читает текущую передачу
     * @return строка с названием передачи или null при ошибке
     */
    fun readGearSelection(): String? = withCarAccess(
        "AutoSeatHeatService: readGearSelection"
    ) { access ->
        val gear = access.readInt(ECARX_PROPERTY_GEAR_SELECTION, 0) ?: return@withCarAccess null
        resetErrorState()
        return@withCarAccess when (gear) {
            1 -> "N"
            2 -> "R"
            4 -> "P"
            8 -> "D"
            16 -> "1"
            32 -> "2"
            64 -> "3"
            128 -> "4"
            256 -> "5"
            512 -> "6"
            else -> "?"
        }
    }

    /**
     * Читает температуру масла двигателя
     * @return температура в °C или null при ошибке
     */
    fun readOilTemperature(): Float? = withCarAccess(
        "AutoSeatHeatService: readOilTemperature"
    ) { access ->
        val rawFloat = access.readFloat(ECARX_PROPERTY_ENGINE_OIL_TEMP, 0)
        val raw = rawFloat ?: access.readInt(ECARX_PROPERTY_ENGINE_OIL_TEMP, 0)?.toFloat()
        if (raw == null) return@withCarAccess null
        resetErrorState()
        return@withCarAccess raw
    }

    /**
     * Читает температуру охлаждающей жидкости
     * @return температура в °C или null при ошибке
     */
    fun readCoolantTemperature(): Float? = withCarAccess(
        "AutoSeatHeatService: readCoolantTemperature"
    ) { access ->
        val rawFloat = access.readFloat(ECARX_PROPERTY_COOLANT_TEMP, 0)
        val raw = rawFloat ?: access.readInt(ECARX_PROPERTY_COOLANT_TEMP, 0)?.toFloat()
        if (raw == null) return@withCarAccess null
        resetErrorState()
        return@withCarAccess raw
    }

    /**
     * Читает скорость автомобиля
     * @return скорость в км/ч или null при ошибке
     */
    fun readVehicleSpeed(): Float? = withCarAccess(
        "AutoSeatHeatService: readVehicleSpeed"
    ) { access ->
        val speed = access.readFloat(ECARX_PROPERTY_VEHICLE_SPEED, 0)
        return@withCarAccess speed?.also { resetErrorState() }
    }

    /**
     * Читает обороты двигателя
     * @return обороты в RPM или null при ошибке
     */
    fun readEngineRPM(): Float? = withCarAccess(
        "AutoSeatHeatService: readEngineRPM"
    ) { access ->
        val rpm = access.readFloat(ECARX_PROPERTY_ENGINE_RPM, 0)
        return@withCarAccess rpm?.also { resetErrorState() }
    }

    /**
     * Тестирует ВСЕ свойства связанные с топливом из дампа.
     * Выводит их значения чтобы найти правильное.
     */
    fun testFuelProperties() {
        DriveModeService.clearConsole()
        DriveModeService.logConsole("=== ТЕСТ ВСЕХ СВОЙСТВ ТОПЛИВА ===")
        if (!ensureCarPropertyManager()) {
            DriveModeService.logConsole("TEST: CarPropertyManager недоступен")
            return
        }
        val pmObj = carPropertyManagerObj ?: run {
            DriveModeService.logConsole("TEST: pmObj is null")
            return
        }

        try {
            val cpmClass = Class.forName("android.car.hardware.property.CarPropertyManager")
            val getIntProperty = cpmClass.getMethod(
                "getIntProperty",
                Int::class.javaPrimitiveType,
                Int::class.javaPrimitiveType
            )
            val getFloatProperty = cpmClass.getMethod(
                "getFloatProperty",
                Int::class.javaPrimitiveType,
                Int::class.javaPrimitiveType
            )

            // Все свойства топлива из дампа
            val fuelProperties = listOf(
                Triple(0x11410105, "INFO_FUEL_TYPE", "int"),
                Triple(0x11400108, "INFO_FUEL_DOOR_LOCATION", "int"),
                Triple(0x11600104, "INFO_FUEL_CAPACITY", "float"), // Ёмкость бака
                Triple(0x2140a136, "IPKFUEL_FUEL_TYPE", "int"),
                Triple(0x11200308, "FUEL_DOOR_OPEN", "int"),
                Triple(0x11600307, "FUEL_LEVEL", "float"), // Текущее - даёт 15000
                Triple(0x2140a565, "IPKINFO_AVERAGE_FUEL_ALL", "int/10"),
                Triple(0x2140a566, "IPKINFO_AVERAGE_FUEL", "int/10"),
                Triple(0x2140a568, "IPKINFO_AVERAGE_INSTANT_FUEL", "int/10"),
                Triple(0x2140a572, "IPKWARN_FUEL", "int"), // Предупреждение о топливе
                Triple(0x11200405, "FUEL_LEVEL_LOW", "int"), // Низкий уровень топлива
                Triple(0x2140a664, "AVERAGE_FUEL_ONE_CYCEL", "int/10"),
                Triple(0x2140a666, "AVERAGE_FUEL_CONSUMPTION_UNIT", "int"),
                Triple(0x11400308, "RANGE_REMAINING", "int"), // Остаток пробега на остатке топлива
            )

            DriveModeService.logConsole("TEST: Проверяю ${fuelProperties.size} свойств топлива...")
            DriveModeService.logConsole("TEST: Сравните значения с приборкой!")
            DriveModeService.logConsole("")

            for ((propId, name, type) in fuelProperties) {
                // Пробуем Float
                try {
                    val floatValue = getFloatProperty.invoke(pmObj, propId, 0) as Float
                    DriveModeService.logConsole("✓ 0x${propId.toString(16)} $name: Float = $floatValue")
                } catch (e: Exception) {
                    // Не Float, пробуем Integer
                    try {
                        val intValue = getIntProperty.invoke(pmObj, propId, 0) as Int
                        val decoded = when {
                            type.contains("/10") -> intValue / 10f
                            type.contains("/100") -> intValue / 100f
                            else -> intValue.toFloat()
                        }
                        if (type.contains("/")) {
                            DriveModeService.logConsole("✓ 0x${propId.toString(16)} $name: Int = $intValue → $decoded ($type)")
                        } else {
                            DriveModeService.logConsole("✓ 0x${propId.toString(16)} $name: Int = $intValue")
                        }
                    } catch (e2: Exception) {
                        DriveModeService.logConsole("✗ 0x${propId.toString(16)} $name: недоступно (${e2.javaClass.simpleName})")
                    }
                }
            }

            DriveModeService.logConsole("")
            DriveModeService.logConsole("=== КОНЕЦ ТЕСТА ===")
            DriveModeService.logConsole("ИНСТРУКЦИЯ: Посмотрите на приборку и найдите какое свойство совпадает с уровнем топлива!")

        } catch (e: Exception) {
            DriveModeService.logConsole("TEST: Критическая ошибка: ${e.javaClass.simpleName}: ${e.message}")
            Log.e(TAG, "Error in testFuelProperties", e)
        }
    }

    /**
     * Диагностика температурных свойств и RPM с разными area
     */
    fun runTemperatureAndRPMDiagnostic() {
        if (!ensureCarPropertyManager()) {
            DriveModeService.logConsole("ДИАГНОСТИКА: CarPropertyManager недоступен")
            return
        }
        val pmObj = carPropertyManagerObj ?: run {
            DriveModeService.logConsole("ДИАГНОСТИКА: pmObj is null")
            return
        }

        try {
            val cpmClass = Class.forName("android.car.hardware.property.CarPropertyManager")
            val getIntProperty = cpmClass.getMethod(
                "getIntProperty",
                Int::class.javaPrimitiveType,
                Int::class.javaPrimitiveType
            )
            val getFloatProperty = cpmClass.getMethod(
                "getFloatProperty",
                Int::class.javaPrimitiveType,
                Int::class.javaPrimitiveType
            )

            val testAreas = listOf(0, 1, 2, 4, 8, 16, 32)

            // Температурные свойства для тестирования
            // Формат: (propertyId, label, divider) где divider: 0f=Float, 8f=Int/8, 10f=Int/10, 1f=Int без деления
            val tempProperties = listOf(
                Triple(0x2140a379, "AC_INSIDE_TEMP", 8f),             // Int/8 - температура в салоне (датчики делят на 8)
                Triple(0x2140a377, "AC_AMBIENT_TEMP", 8f),            // Int/8 - температура снаружи (датчики делят на 8)
                Triple(0x11600703, "ENV_OUTSIDE_TEMPERATURE", 0f),    // Float - наружная температура
                Triple(0x21404515, "HU_ENVIRONMENTAL_TEMP", 10f),     // Int/10 - температура окружающей среды
                Triple(0x2140101d, "HVAC_IN_OUT_TEMP", 10f),          // Int/10 - температура HVAC
                Triple(0x11600304, "ENGINE_OIL_TEMP", 10f),           // Int/10 - температура масла двигателя
                Triple(0x2140a578, "IPKINFO_COOLAN_TEMP", 1f),        // Int без деления - температура охлаждающей жидкости
                Triple(0x2140a324, "ENGINE_COOLAN_TEMPERATURE", 1f),  // Int без деления - температура охлаждающей жидкости (альт)
                Triple(0x21408017, "ENGINE_COOLANT_TEMP", 1f),        // Int без деления - температура охлаждающей жидкости (еще один)
                Triple(0x15600503, "ZONED_TEMP_SETPOINT", 10f)        // Int/10 - установка температуры по зонам
            )

            // RPM свойства для тестирования
            // Формат: (propertyId, label, isInt)
            val rpmProperties = listOf(
                Triple(0x11600305, "ENGINE_RPM", false),              // Float - обороты двигателя (стандартный)
                Triple(0x2140a609, "EMS_ENGINE_SPEED_RPM", true),     // Int - обороты двигателя (альтернативный)
                Triple(0x2140800e, "DRIVE_ENGINE_STATUS", true),      // Int - статус двигателя
                Triple(0x214020ac, "DRIVE_ENGINE_START_ON", true),    // Int - двигатель запущен
                Triple(0x2140a313, "PMS_PT_READY", true),             // Int - двигатель готов
                Triple(0x11600207, "VEHICLE_SPEED", false)            // Float - скорость (для сравнения)
            )

            DriveModeService.logConsole("--- ТЕМПЕРАТУРНЫЕ СВОЙСТВА ---")
            DriveModeService.logConsole("")

            for ((propertyId, label, divider) in tempProperties) {
                DriveModeService.logConsole("$label (0x${propertyId.toString(16)}):")
                var foundAny = false
                for (area in testAreas) {
                    try {
                        val temp = if (divider > 0f) {
                            val intValue = getIntProperty.invoke(pmObj, propertyId, area) as Int
                            val temperature = intValue / divider
                            val dividerStr = when(divider) {
                                8f -> "/8"
                                10f -> "/10"
                                1f -> ""
                                else -> "/$divider"
                            }
                            DriveModeService.logConsole("  ✓ area=$area: ${temperature.toInt()}°C (raw=$intValue$dividerStr)")
                            foundAny = true
                            temperature
                        } else {
                            val floatValue = getFloatProperty.invoke(pmObj, propertyId, area) as Float
                            DriveModeService.logConsole("  ✓ area=$area: ${floatValue.toInt()}°C")
                            foundAny = true
                            floatValue
                        }
                    } catch (e: Exception) {
                        // Не логируем ошибки для каждого area
                    }
                }
                if (!foundAny) {
                    DriveModeService.logConsole("  ✗ Недоступно во всех area")
                }
                DriveModeService.logConsole("")
            }

            DriveModeService.logConsole("--- ОБОРОТЫ (RPM) ---")
            DriveModeService.logConsole("")

            for ((propertyId, label, isInt) in rpmProperties) {
                DriveModeService.logConsole("$label (0x${propertyId.toString(16)}):")
                var foundAny = false
                for (area in testAreas) {
                    try {
                        val value = if (isInt) {
                            val intValue = getIntProperty.invoke(pmObj, propertyId, area) as Int
                            DriveModeService.logConsole("  ✓ area=$area: $intValue RPM")
                            foundAny = true
                            intValue
                        } else {
                            val floatValue = getFloatProperty.invoke(pmObj, propertyId, area) as Float
                            DriveModeService.logConsole("  ✓ area=$area: ${floatValue.toInt()} RPM (raw=${floatValue})")
                            foundAny = true
                            floatValue
                        }
                    } catch (e: Exception) {
                        // Не логируем ошибки для каждого area
                    }
                }
                if (!foundAny) {
                    DriveModeService.logConsole("  ✗ Недоступно во всех area")
                }
                DriveModeService.logConsole("")
            }

            DriveModeService.logConsole("=== КОНЕЦ ДИАГНОСТИКИ ===")

        } catch (e: Exception) {
            DriveModeService.logConsole("ДИАГНОСТИКА: Критическая ошибка: ${e.javaClass.simpleName}: ${e.message}")
            Log.e(TAG, "Error in runTemperatureAndRPMDiagnostic", e)
        }
    }


    /**
     * Читает данные TPMS (давление и температуру всех 4 шин)
     * @return TirePressureData с данными всех шин или null при ошибке
     */
    fun readTirePressureData(): TirePressureData? = withCarAccess(
        "AutoSeatHeatService: readTirePressureData"
    ) { access ->

        fun readTpmsPressure(propertyId: Int, label: String): Int? {
            return try {
                val floatValue = access.readFloat(propertyId, 0)
                floatValue?.toInt()
            } catch (e: Exception) {
                DriveModeService.logConsole("$label: ошибка = ${e.javaClass.simpleName}: ${e.message}")
                null
            }
        }

        fun readTpmsTemperature(propertyId: Int, label: String): Int? {
            return try {
                val raw = access.readInt(propertyId, 0) ?: return null
                raw / 8
            } catch (e: Exception) {
                DriveModeService.logConsole("$label: ошибка = ${e.javaClass.simpleName}: ${e.message}")
                null
            }
        }

        val frontLeft = TireData(
            pressure = readTpmsPressure(ECARX_PROPERTY_TPMS_PRESSURE_FL, "TPMS FL давление"),
            temperature = readTpmsTemperature(ECARX_PROPERTY_TPMS_TEMP_FL, "TPMS FL температура")
        )

        val frontRight = TireData(
            pressure = readTpmsPressure(ECARX_PROPERTY_TPMS_PRESSURE_FR, "TPMS FR давление"),
            temperature = readTpmsTemperature(ECARX_PROPERTY_TPMS_TEMP_FR, "TPMS FR температура")
        )

        val rearLeft = TireData(
            pressure = readTpmsPressure(ECARX_PROPERTY_TPMS_PRESSURE_RL, "TPMS RL давление"),
            temperature = readTpmsTemperature(ECARX_PROPERTY_TPMS_TEMP_RL, "TPMS RL температура")
        )

        val rearRight = TireData(
            pressure = readTpmsPressure(ECARX_PROPERTY_TPMS_PRESSURE_RR, "TPMS RR давление"),
            temperature = readTpmsTemperature(ECARX_PROPERTY_TPMS_TEMP_RR, "TPMS RR температура")
        )

        resetErrorState()
        TirePressureData(
            frontLeft = frontLeft,
            frontRight = frontRight,
            rearLeft = rearLeft,
            rearRight = rearRight
        )
    }

    // Применение автоматического подогрева сидений
    private fun applyAutoSeatHeat(test: Boolean) {
        val prefs = getSharedPreferences("drivemode_prefs", Context.MODE_PRIVATE)
        val mode = prefs.getString("seat_auto_heat_mode", "off") ?: "off"

        if (mode == "off") {
            DriveModeService.logConsole(
                if (test) "seatHeat test: mode=off, nothing to do"
                else "seatHeat auto: mode=off, skip"
            )
            return
        }

        if (!ensureCarPropertyManager()) {
            DriveModeService.logConsole("seatHeat: CarPropertyManager not available")
            return
        }

        val pmObj = carPropertyManagerObj ?: run {
            DriveModeService.logConsole("seatHeat: CarPropertyManager is null, cannot set heat")
            return
        }

        val propertyId = VEHICLE_PROPERTY_HVAC_SEAT_TEMPERATURE
        val targets = when (mode) {
            "driver" -> listOf(1)
            "passenger" -> listOf(4)
            "both" -> listOf(1, 4)
            else -> emptyList()
        }
        if (targets.isEmpty()) {
            DriveModeService.logConsole("seatHeat: no targets for mode=$mode")
            return
        }

        // Читаем настройку адаптивного обогрева
        val adaptiveHeating = prefs.getBoolean("adaptive_heating", false)

        // Определяем уровень обогрева
        val level = if (adaptiveHeating) {
            // ПРИОРИТЕТ 1: Адаптивный режим - выбираем уровень на основе температуры в салоне
            // Порог температуры игнорируется!
            val cabinTemp = readCabinTemperature()
            val adaptiveLevel = when {
                cabinTemp == null -> {
                    DriveModeService.logConsole("seatHeat [АДАПТИВ]: температура салона недоступна, использую уровень 1")
                    1
                }
                cabinTemp <= 0f -> {
                    DriveModeService.logConsole("seatHeat [АДАПТИВ]: температура ≤0°C (${cabinTemp.toInt()}°C) → уровень 3")
                    3
                }
                cabinTemp < 5f -> {
                    DriveModeService.logConsole("seatHeat [АДАПТИВ]: температура <5°C (${cabinTemp.toInt()}°C) → уровень 2")
                    2
                }
                cabinTemp < 10f -> {
                    DriveModeService.logConsole("seatHeat [АДАПТИВ]: температура <10°C (${cabinTemp.toInt()}°C) → уровень 1")
                    1
                }
                else -> {
                    DriveModeService.logConsole("seatHeat [АДАПТИВ]: температура ≥10°C (${cabinTemp.toInt()}°C) → обогрев не нужен")
                    0 // Не включаем обогрев
                }
            }
            adaptiveLevel
        } else {
            // ПРИОРИТЕТ 2: Адаптив выключен - проверяем температурный порог
            val tempThresholdEnabled = prefs.getBoolean("seat_heat_temp_threshold_enabled", false)
            if (tempThresholdEnabled) {
                val cabinTemp = readCabinTemperature()
                if (cabinTemp == null) {
                    DriveModeService.logConsole("seatHeat [ПОРОГ]: температура недоступна, использую фиксированный уровень")
                } else {
                    val threshold = prefs.getFloat("seat_heat_temp_threshold", 12f)
                    if (cabinTemp >= threshold) {
                        DriveModeService.logConsole(
                            "seatHeat [ПОРОГ]: температура ${cabinTemp.toInt()}°C ≥ ${threshold.toInt()}°C → обогрев не нужен"
                        )
                        return // Не включаем обогрев
                    }
                    DriveModeService.logConsole(
                        "seatHeat [ПОРОГ]: температура ${cabinTemp.toInt()}°C < ${threshold.toInt()}°C → включаем"
                    )
                }
            } else {
                DriveModeService.logConsole("seatHeat [БАЗОВЫЙ]: порог выключен, всегда включаем обогрев")
            }
            // ПРИОРИТЕТ 3: Фиксированный режим - читаем выбранную пользователем мощность (1-3)
            prefs.getInt("seat_heat_level", 1).coerceIn(1, 3)
        }

        // Если адаптивный режим решил не включать обогрев (temp >= 10°C)
        if (level == 0) {
            DriveModeService.logConsole("seatHeat: адаптивный режим - обогрев не требуется")
            return
        }

        var successAll = true

        try {
            val cpmClass = Class.forName("android.car.hardware.property.CarPropertyManager")
            val setIntProperty = cpmClass.getMethod(
                "setIntProperty",
                Int::class.javaPrimitiveType,
                Int::class.javaPrimitiveType,
                Int::class.javaPrimitiveType
            )
            for (areaId in targets) {
                try {
                    setIntProperty.invoke(pmObj, propertyId, areaId, level)
                    DriveModeService.logConsole("seatHeat: set area=$areaId level=$level (mode=$mode, test=$test)")
                } catch (e: Exception) {
                    successAll = false
                    DriveModeService.logConsole(
                        "seatHeat: error set area=$areaId: ${e.javaClass.simpleName}: ${e.message}"
                    )
                }
            }
        } catch (e: Exception) {
            successAll = false
            DriveModeService.logConsole(
                "seatHeat: reflection invocation error: ${e.javaClass.simpleName}: ${e.message}"
            )
        }

        if (!test) {
            DriveModeService.logConsole("seatHeat auto applied: mode=$mode, success=$successAll")
        } else {
            DriveModeService.logConsole("seatHeat test done: mode=$mode, success=$successAll")
        }
    }
}